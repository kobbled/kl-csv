PROGRAM csv
%NOLOCKGROUP

%include errors.klt
%include csv.klt

%include errors.klh
%include strings.klh
%include files.klh
%include csv.private.klh
%include csv.klh

ROUTINE csv__create
  BEGIN
    --set delimeter
    csv__set_delimeter(delim)
    --set fieldnames
    csv__set_fieldnames(header)
    --write fieldnames
    csv__write_fieldnames(file_name, csv_fl)
    
  END csv__create

ROUTINE csv__write_string
  VAR
    i : INTEGER
    s : STRING[254]
  BEGIN
    IF ARRAY_LEN(row) > columns THEN
      karelError('row length ' + i_to_s(ARRAY_LEN(row)) + ' is larger than number '+ CHR(13) + &
                  'of columns '+ i_to_s(columns) + ' in csv file', ER_WARN_STP)
    ENDIF

    s = ''
    FOR i=1 TO columns DO
      IF UNINIT(row[i]) THEN karelError('uninitialized data in col: ' + i_to_s(i) +  & 
                                        ' passed to csv file', ER_ABORT) ; ENDIF
      s = s + row[i]
      IF i < columns THEN
        s = s + delimeter
      ENDIF
    ENDFOR

    -- write to pipe
    OPEN FILE fl ('AP', file_name)

    WRITE fl(s)
    IF (s <> '') THEN
      WRITE fl(CR)
    ENDIF

    CLOSE FILE fl

  END csv__write_string

ROUTINE csv__write_fieldnames
  VAR
    i : INTEGER
    s : STRING[254]
  BEGIN
    -- write header
    s = ''
    FOR i=1 TO columns DO
      s = s + fieldnames[i]
      IF i < columns THEN
        s = s + delimeter
      ENDIF
    ENDFOR

    --open csv to write header
    files__open(file_name, 'RW', csv_fl)

    WRITE csv_fl(s)
    IF (s <> '') THEN
      WRITE csv_fl(CR)
    ENDIF

    files__close(file_name, csv_fl)

  END csv__write_fieldnames

ROUTINE csv__write_row_val
  VAR
    i : INTEGER
    row_s : ARRAY[CSV_MAX_COLUMNS] OF STRING[CSV_CELL_LENGTH]
  BEGIN
    IF ARRAY_LEN(row) > ARRAY_LEN(row_s) THEN
      karelError('real row is greater than max csv columns, ' + i_to_s(CSV_MAX_COLUMNS), ER_ABORT)
    ENDIF

    FOR i=1 TO ARRAY_LEN(row) DO
      row_s[i] = r_to_s(row[i])
    ENDFOR

    csv__write_string(file_name, csv_fl, row_s)
  END csv__write_row_val

ROUTINE csv__write_row_string
  BEGIN
    csv__write_string(file_name, csv_fl, row)
  END csv__write_row_string

ROUTINE csv__write_row_vector
  VAR
    row_s : ARRAY[3] OF STRING[CSV_CELL_LENGTH]
  BEGIN
    row_s[1] = r_to_s(row.x) 
    row_s[2] = r_to_s(row.y)
    row_s[3] = r_to_s(row.z)
    csv__write_string(file_name, csv_fl, row_s)
  END csv__write_row_vector

ROUTINE csv__write_row_xyzwpr
  VAR
    row_s : ARRAY[6] OF STRING[CSV_CELL_LENGTH]
  BEGIN
    row_s[1] = r_to_s(row.x) 
    row_s[2] = r_to_s(row.y)
    row_s[3] = r_to_s(row.z)
    row_s[4] = r_to_s(row.w) 
    row_s[5] = r_to_s(row.p)
    row_s[6] = r_to_s(row.r)
    csv__write_string(file_name, csv_fl, row_s)
  END csv__write_row_xyzwpr


ROUTINE csv__set_delimeter
  BEGIN
    IF STR_LEN(delim) > 1 THEN karelError('csv delimeter must be a single char', ER_ABORT) ; ENDIF
    delim_check(delim)

    delimeter = delim
  END csv__set_delimeter

ROUTINE csv__set_fieldnames
  VAR
    i : INTEGER
    c : INTEGER
  BEGIN
    --clear fieldnames
    csv__clear_fieldnames
    --split header against delimeter
    split_str(header, delimeter, fieldnames)
    --tally columns
    c = 0
    FOR i=1 TO ARRAY_LEN(fieldnames) DO
      IF fieldnames[i] <> '' THEN c = c + 1 ; ENDIF
    ENDFOR

    columns = c
  END csv__set_fieldnames

ROUTINE csv__clear_fieldnames
  VAR
    i : INTEGER
  BEGIN
    FOR i=1 TO ARRAY_LEN(fieldnames) DO 
      fieldnames[i] = ''
    ENDFOR
  END csv__clear_fieldnames


ROUTINE csv__read_open
  BEGIN
    --open pipe
    OPEN FILE pip ('RO', file_name)
  END csv__read_open

ROUTINE csv__read_close
  BEGIN
    --close pipe
    CLOSE FILE pip
  END csv__read_close

ROUTINE csv__read_pipe
  VAR
    str : STRING[127]
    buf, status : INTEGER
  BEGIN
    --see if there is still data to read
    BYTES_AHEAD(pip, buf, status)

    --close file if BYTES_AHEAD fails
    IF status <> 0 THEN
      csv__read_close(pip)
    ENDIF

    IF buf > 0 THEN
      --read line
      READ pip (str)
    ENDIF

    RETURN(str)

  END csv__read_pipe

ROUTINE csv__read_pipe_rarr
  BEGIN
    IF (UNINIT(delimeter)) OR (delimeter = '') THEN
      karelError('delimeter not set before read operation', ER_ABORT)
    ENDIF

    --read line and output as real array
    s_to_rarr(csv__read_pipe(pip), delimeter, out_arr)

  END csv__read_pipe_rarr

ROUTINE csv__read_pipe_vector
  BEGIN
    IF (UNINIT(delimeter)) OR (delimeter = '') THEN
      karelError('delimeter not set before read operation', ER_ABORT)
    ENDIF

    --read line and output as vector
    RETURN(s_to_vec(csv__read_pipe(pip), delimeter))
  END csv__read_pipe_vector

ROUTINE csv__read_pipe_xyzwpr
  BEGIN
    IF (UNINIT(delimeter)) OR (delimeter = '') THEN
      karelError('delimeter not set before read operation', ER_ABORT)
    ENDIF
    
    --read line and output as vector
    RETURN(s_to_xyzwpr(csv__read_pipe(pip), delimeter))
  END csv__read_pipe_xyzwpr

BEGIN
END csv
